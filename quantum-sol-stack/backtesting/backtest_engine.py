"""
Backtesting Engine for QuantumSol AI Trading System

This module provides a robust backtesting framework that integrates with the existing
Data Manager to test trading strategies against historical data.
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Union, Callable, Any
import pandas as pd
import numpy as np
from dataclasses import dataclass, field
from enum import Enum, auto
import yaml
import os

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class BacktestMode(Enum):
    """Enum for different backtesting modes."""
    BACKTEST = auto()
    PAPER = auto()
    LIVE = auto()

@dataclass
class BacktestConfig:
    """Configuration for the backtesting engine."""
    mode: BacktestMode = BacktestMode.BACKTEST
    initial_capital: float = 10000.0
    quote_currency: str = 'USD'
    start_date: str = (datetime.utcnow() - timedelta(days=365*5)).strftime('%Y-%m-%d')
    end_date: str = datetime.utcnow().strftime('%Y-%m-%d')
    data_dir: str = 'data/backtest'
    fee_rate: float = 0.001  # 0.1% fee per trade
    slippage: float = 0.0005  # 0.05% slippage
    max_open_positions: int = 10
    risk_per_trade: float = 0.01  # 1% risk per trade

@dataclass
class TradeSignal:
    """Represents a trading signal generated by a strategy."""
    symbol: str
    direction: int  # 1 for long, -1 for short, 0 for close/neutral
    price: float
    timestamp: datetime
    size: Optional[float] = None  # Position size in base currency
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Position:
    """Represents an open position in the portfolio."""
    symbol: str
    entry_price: float
    size: float  # Position size in base currency
    direction: int  # 1 for long, -1 for short
    entry_time: datetime
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    pnl: float = 0.0  # Unrealized P&L
    pnl_pct: float = 0.0  # Unrealized P&L percentage
    metadata: Dict[str, Any] = field(default_factory=dict)

    def update(self, current_price: float) -> None:
        """Update the position with the current market price."""
        if self.direction == 1:  # Long
            self.pnl = (current_price - self.entry_price) * self.size
        else:  # Short
            self.pnl = (self.entry_price - current_price) * self.size
        self.pnl_pct = (self.pnl / (self.entry_price * self.size)) * 100 if self.entry_price > 0 else 0.0

class BacktestEngine:
    """
    Main backtesting engine that orchestrates the backtesting process.
    
    This class is responsible for:
    1. Loading and preparing historical data
    2. Executing the strategy on the data
    3. Managing the portfolio and orders
    4. Calculating performance metrics
    """
    
    def __init__(self, strategy: Callable, config: Optional[BacktestConfig] = None):
        """
        Initialize the backtesting engine.
        
        Args:
            strategy: A callable that implements the trading strategy
            config: Backtest configuration (uses defaults if None)
        """
        self.strategy = strategy
        self.config = config or BacktestConfig()
        self.positions: Dict[str, Position] = {}
        self.trade_history: List[Dict] = []
        self.portfolio_value = []
        self.timestamps = []
        self.data: Dict[str, pd.DataFrame] = {}
        self.current_prices: Dict[str, float] = {}
        
        # Initialize data manager
        from .data_manager.data_manager import DataManager
        self.data_manager = DataManager()
    
    def load_data(self, symbols: List[str], interval: str = '1d') -> None:
        """
        Load historical data for the specified symbols and time range.
        
        Args:
            symbols: List of trading symbols (e.g., ['BTC/USD', 'ETH/USD'])
            interval: Data interval (e.g., '1d', '1h', '4h')
        """
        logger.info(f"Loading data for {symbols} from {self.config.start_date} to {self.config.end_date}")
        
        for symbol in symbols:
            base, quote = symbol.split('/')
            
            try:
                # Fetch data using the data manager
                df = self.data_manager.fetch_ohlcv(
                    symbol=base,
                    currency=quote,
                    interval=interval,
                    start_date=self.config.start_date,
                    end_date=self.config.end_date,
                    normalize=True
                )
                
                if df.empty:
                    logger.warning(f"No data found for {symbol}")
                    continue
                
                # Store the data with symbol as key
                self.data[symbol] = df
                logger.info(f"Loaded {len(df)} rows for {symbol}")
                
            except Exception as e:
                logger.error(f"Error loading data for {symbol}: {str(e)}")
    
    def run(self) -> Dict[str, Any]:
        """
        Run the backtest.
        
        Returns:
            Dictionary containing backtest results and performance metrics
        """
        if not self.data:
            raise ValueError("No data loaded. Call load_data() first.")
        
        logger.info("Starting backtest...")
        
        # Get all unique timestamps across all symbols
        all_timestamps = set()
        for df in self.data.values():
            all_timestamps.update(df['timestamp'])
        
        # Sort timestamps chronologically
        sorted_timestamps = sorted(all_timestamps)
        
        # Initialize portfolio
        portfolio = Portfolio(
            initial_capital=self.config.initial_capital,
            quote_currency=self.config.quote_currency,
            fee_rate=self.config.fee_rate,
            slippage=self.config.slippage
        )
        
        # Main backtest loop
        for timestamp in sorted_timestamps:
            self.current_time = timestamp
            
            # Update current prices for all symbols
            for symbol, df in self.data.items():
                row = df[df['timestamp'] == timestamp]
                if not row.empty:
                    self.current_prices[symbol] = row['close'].values[0]
            
            # Execute strategy
            signals = self.strategy(self, timestamp, self.current_prices, portfolio)
            
            # Process signals
            if signals:
                for signal in signals:
                    self._process_signal(signal, portfolio)
            
            # Update portfolio
            portfolio.update(timestamp, self.current_prices)
            
            # Record portfolio value
            self.portfolio_value.append(portfolio.total_value)
            self.timestamps.append(timestamp)
        
        # Generate performance report
        report = self._generate_report(portfolio)
        
        logger.info("Backtest completed successfully")
        return report
    
    def _process_signal(self, signal: TradeSignal, portfolio: 'Portfolio') -> None:
        """Process a trading signal."""
        try:
            if signal.direction == 0:
                # Close position
                if signal.symbol in self.positions:
                    position = self.positions[signal.symbol]
                    portfolio.close_position(position, signal.price, signal.timestamp)
                    del self.positions[signal.symbol]
            else:
                # Open new position or adjust existing one
                if signal.symbol in self.positions:
                    # Adjust existing position
                    position = self.positions[signal.symbol]
                    # For simplicity, we'll just close and reopen for now
                    portfolio.close_position(position, signal.price, signal.timestamp)
                    del self.positions[signal.symbol]
                
                # Calculate position size if not provided
                if signal.size is None:
                    signal.size = portfolio.calculate_position_size(
                        signal.price,
                        signal.stop_loss,
                        self.config.risk_per_trade
                    )
                
                # Open new position
                position = Position(
                    symbol=signal.symbol,
                    entry_price=signal.price,
                    size=signal.size,
                    direction=signal.direction,
                    entry_time=signal.timestamp,
                    stop_loss=signal.stop_loss,
                    take_profit=signal.take_profit,
                    metadata=signal.metadata
                )
                
                portfolio.open_position(position, signal.price, signal.timestamp)
                self.positions[signal.symbol] = position
                
        except Exception as e:
            logger.error(f"Error processing signal {signal}: {str(e)}")
    
    def _generate_report(self, portfolio: 'Portfolio') -> Dict[str, Any]:
        """
        Generate a performance report with metrics and visualizations.
        
        Args:
            portfolio: The portfolio containing trade history and performance data
            
        Returns:
            Dictionary containing performance metrics and visualization figures
        """
        # Calculate basic performance metrics
        returns = pd.Series([t['pnl_pct'] for t in portfolio.trade_history if t.get('pnl_pct') is not None])
        total_return = (portfolio.total_value - portfolio.initial_capital) / portfolio.initial_capital * 100
        
        # Calculate additional metrics
        if len(portfolio.timestamps) > 1:
            days = (portfolio.timestamps[-1] - portfolio.timestamps[0]).days
            years = max(days / 365.25, 0.00274)  # At least 1 day to avoid division by zero
            
            # Calculate annualized return
            annualized_return = ((portfolio.total_value / portfolio.initial_capital) ** (1/years) - 1) * 100
            
            # Calculate Sharpe ratio (assuming risk-free rate of 2%)
            risk_free_rate = 0.02
            excess_returns = returns - (risk_free_rate / 252)  # Daily risk-free rate
            sharpe_ratio = (excess_returns.mean() / (excess_returns.std() + 1e-9)) * np.sqrt(252)
            
            # Calculate max drawdown
            cum_returns = (1 + returns).cumprod()
            rolling_max = cum_returns.cummax()
            drawdowns = (cum_returns - rolling_max) / rolling_max
            max_drawdown = drawdowns.min() * 100 if not drawdowns.empty else 0.0
        else:
            annualized_return = 0.0
            sharpe_ratio = 0.0
            max_drawdown = 0.0
        
        # Create a BacktestResult object for visualization
        from backtesting.visualization.base_visualizer import BacktestVisualizer
        from backtesting.visualization.equity_curve import plot_equity_curve
        from backtesting.visualization.drawdown import plot_drawdown
        from backtesting.visualization.returns import plot_returns_distribution
        from backtesting.visualization.trade_analysis import plot_trade_performance
        from backtesting.visualization.rolling_metrics import plot_rolling_metrics
        
        # Prepare portfolio history DataFrame
        portfolio_history = pd.DataFrame({
            'total_value': [v for v in portfolio.value_history],
            'returns': [0] + [portfolio.value_history[i]/portfolio.value_history[i-1]-1 
                            for i in range(1, len(portfolio.value_history))]
        }, index=portfolio.timestamps)
        
        # Calculate trade metrics
        total_trades = len(portfolio.trade_history)
        winning_trades = len([t for t in portfolio.trade_history if t.get('pnl', 0) > 0])
        losing_trades = total_trades - winning_trades
        win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
        
        # Create report
        report = {
            'overview': {
                'initial_capital': self.config.initial_capital,
                'final_value': self.portfolio_value[-1],
                'total_return_pct': total_return,
                'annualized_return_pct': annualized_return,
                'sharpe_ratio': sharpe_ratio,
                'max_drawdown_pct': max_drawdown,
                'total_trades': total_trades,
                'win_rate_pct': win_rate,
                'profit_factor': None,  # Would be calculated from trade P&L
                'start_date': self.timestamps[0].isoformat() if self.timestamps else None,
                'end_date': self.timestamps[-1].isoformat() if self.timestamps else None,
                'quote_currency': self.config.quote_currency
            },
            'trades': portfolio.trade_history,
            'equity_curve': {
                'timestamps': [t.isoformat() for t in self.timestamps],
                'values': self.portfolio_value
            },
            'positions': [vars(pos) for pos in self.positions.values()]
        }
        
        return report

class Portfolio:
    """
    Manages a portfolio of positions and cash balance.
    """
    
    def __init__(
        self,
        initial_capital: float = 10000.0,
        quote_currency: str = 'USD',
        fee_rate: float = 0.001,
        slippage: float = 0.0005
    ):
        """
        Initialize the portfolio.
        
        Args:
            initial_capital: Starting cash balance
            quote_currency: Base currency of the portfolio
            fee_rate: Trading fee as a fraction (e.g., 0.001 for 0.1%)
            slippage: Expected slippage as a fraction (e.g., 0.0005 for 0.05%)
        """
        self.cash = initial_capital
        self.initial_capital = initial_capital
        self.quote_currency = quote_currency
        self.fee_rate = fee_rate
        self.slippage = slippage
        self.positions: Dict[str, Position] = {}
        self.trade_history = []
        self.value_history = []
        self.timestamps = []
    
    @property
    def total_value(self) -> float:
        """Calculate the total portfolio value (cash + positions)."""
        positions_value = sum(
            (pos.entry_price + pos.pnl) * pos.size 
            for pos in self.positions.values()
        )
        return self.cash + positions_value
    
    def update(self, timestamp: datetime, prices: Dict[str, float]) -> None:
        """
        Update the portfolio with current market prices.
        
        Args:
            timestamp: Current timestamp
            prices: Dictionary of symbol -> current price
        """
        # Update position P&L
        for symbol, position in self.positions.items():
            if symbol in prices:
                position.update(prices[symbol])
        
        # Record portfolio value
        self.value_history.append(self.total_value)
        self.timestamps.append(timestamp)
    
    def calculate_position_size(
        self,
        entry_price: float,
        stop_loss: Optional[float],
        risk_per_trade: float = 0.01
    ) -> float:
        """
        Calculate position size based on risk parameters.
        
        Args:
            entry_price: Entry price
            stop_loss: Stop loss price
            risk_per_trade: Fraction of capital to risk per trade
            
        Returns:
            Position size in base currency
        """
        if stop_loss is None or stop_loss <= 0:
            # Default to 1% of portfolio if no stop loss
            return self.total_value * risk_per_trade / entry_price
        
        # Calculate position size based on risk
        risk_amount = self.total_value * risk_per_trade
        risk_per_share = abs(entry_price - stop_loss)
        
        # Add buffer for slippage and fees
        risk_per_share *= (1 + self.slippage + self.fee_rate)
        
        if risk_per_share <= 0:
            return 0.0
            
        return risk_amount / risk_per_share
    
    def open_position(self, position: Position, current_price: float, timestamp: datetime) -> None:
        """
        Open a new position.
        
        Args:
            position: Position to open
            current_price: Current market price
            timestamp: Current timestamp
        """
        # Calculate total cost including fees
        cost = position.entry_price * position.size
        fee = cost * self.fee_rate
        total_cost = cost + fee
        
        if total_cost > self.cash:
            raise ValueError("Insufficient funds to open position")
        
        # Deduct from cash
        self.cash -= total_cost
        
        # Add to positions
        self.positions[position.symbol] = position
        
        # Log the trade
        self.trade_history.append({
            'timestamp': timestamp.isoformat(),
            'symbol': position.symbol,
            'action': 'OPEN',
            'direction': 'LONG' if position.direction > 0 else 'SHORT',
            'price': position.entry_price,
            'size': position.size,
            'fee': fee,
            'pnl': 0.0,
            'pnl_pct': 0.0,
            'balance': self.cash,
            'metadata': position.metadata
        })
    
    def close_position(self, position: Position, current_price: float, timestamp: datetime) -> None:
        """
        Close an existing position.
        
        Args:
            position: Position to close
            current_price: Current market price
            timestamp: Current timestamp
        """
        if position.symbol not in self.positions:
            raise ValueError(f"No open position found for {position.symbol}")
        
        # Calculate P&L
        if position.direction == 1:  # Long
            pnl = (current_price - position.entry_price) * position.size
        else:  # Short
            pnl = (position.entry_price - current_price) * position.size
        
        # Calculate fees
        fee = (position.entry_price * position.size) * self.fee_rate
        
        # Update cash
        self.cash += (position.entry_price * position.size) + pnl - fee
        
        # Calculate P&L percentage
        pnl_pct = (pnl / (position.entry_price * position.size)) * 100
        
        # Log the trade
        self.trade_history.append({
            'timestamp': timestamp.isoformat(),
            'symbol': position.symbol,
            'action': 'CLOSE',
            'direction': 'LONG' if position.direction > 0 else 'SHORT',
            'price': current_price,
            'size': position.size,
            'fee': fee,
            'pnl': pnl,
            'pnl_pct': pnl_pct,
            'balance': self.cash,
            'metadata': position.metadata
        })
        
        # Remove from positions
        del self.positions[position.symbol]

def example_strategy(
    engine: BacktestEngine, 
    timestamp: datetime, 
    prices: Dict[str, float],
    portfolio: Portfolio
) -> List[TradeSignal]:
    """
    Example trading strategy that generates signals.
    
    This is a simple moving average crossover strategy.
    Replace this with your actual strategy implementation.
    """
    signals = []
    
    for symbol, df in engine.data.items():
        if len(df) < 20:  # Need enough data for indicators
            continue
            
        # Get recent data
        recent = df[df['timestamp'] <= timestamp].tail(50)
        
        if len(recent) < 50:  # Not enough data yet
            continue
            
        # Calculate indicators
        short_ma = recent['close'].rolling(window=10).mean().iloc[-1]
        long_ma = recent['close'].rolling(window=30).mean().iloc[-1]
        
        current_price = prices.get(symbol)
        if current_price is None:
            continue
            
        # Generate signals
        if short_ma > long_ma and symbol not in engine.positions:
            # Buy signal
            signals.append(TradeSignal(
                symbol=symbol,
                direction=1,  # Long
                price=current_price,
                timestamp=timestamp,
                stop_loss=recent['low'].min(),  # Example stop loss
                take_profit=current_price * 1.1  # Example take profit
            ))
        elif short_ma < long_ma and symbol in engine.positions:
            # Sell signal
            signals.append(TradeSignal(
                symbol=symbol,
                direction=0,  # Close position
                price=current_price,
                timestamp=timestamp
            ))
    
    return signals

def load_config(config_path: str) -> BacktestConfig:
    """
    Load backtest configuration from a YAML file.
    
    Args:
        config_path: Path to the configuration file
        
    Returns:
        BacktestConfig object
    """
    with open(config_path, 'r') as f:
        config_data = yaml.safe_load(f)
    
    return BacktestConfig(**config_data)

if __name__ == "__main__":
    # Example usage
    config = BacktestConfig(
        initial_capital=10000.0,
        quote_currency='USD',
        start_date='2020-01-01',
        end_date='2023-01-01',
        fee_rate=0.001,
        slippage=0.0005
    )
    
    # Initialize backtest engine with example strategy
    engine = BacktestEngine(example_strategy, config)
    
    # Load data
    engine.load_data(['BTC/USD', 'ETH/USD'], interval='1d')
    
    # Run backtest
    results = engine.run()
    
    # Print results
    print(f"Final Portfolio Value: {results['overview']['final_value']:.2f} {config.quote_currency}")
    print(f"Total Return: {results['overview']['total_return_pct']:.2f}%")
    print(f"Sharpe Ratio: {results['overview']['sharpe_ratio']:.2f}")
    print(f"Max Drawdown: {results['overview']['max_drawdown_pct']:.2f}%")
    print(f"Total Trades: {results['overview']['total_trades']}")
